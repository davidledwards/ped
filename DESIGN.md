# Design

The core data structure for managing text is a [gap buffer](https://en.wikipedia.org/wiki/Gap_buffer) defined in `buffer.rs`, which turns out to be very efficient for insertion and removal operations. This is the only module that contains _unsafe_ Rust by design, primarily because the data structure requires something similar to a `Vec`, which could have been used but would have been too restrictive and less efficient. The simple idea behind the gap buffer that makes insertion and removal so efficient, _O(1)_, is that as the cursor moves so does the text before and after the gap. In essence, the cursor always points to the start of the gap, making insertion and removal a constant-time operation. This implementation has been slightly modified to defer any movement of text until a mutating change occurs.

The only other module that contains _unsafe_ Rust, by necessity, is `term.rs`, which makes calls to the C runtime library to interact with the terminal.

The display of text on the terminal is ultimately done using ANSI control sequences, but there are intermediate steps in the process that optimize the amount of data sent to the terminal. A key component of the display architecture is a _canvas_ that is essentially an abstraction over _stdout_. Central to the design of the canvas is the combination of a _front_ and _back_ grid, a two-dimensional data structure. The front grid is a faithful representation of what the user sees, whereas the back grid is a cache of pending updates. The idea is that a series of writes are applied to the back grid, and then a subsequent draw request will generate a minimal set of ANSI commands based on the differences between the front and back grids.

The rendering process is a possibly novel approach, as I did zero research on existing methods implemented in other editors. Since the text buffer is not organized as a collection of lines, but rather a contiguous array of characters with a gap in the middle, efficient rendering turned out to be one of the more difficult problems to solve. These core challenges include scrolling, insertion and removal of text, and line wrapping among others. It became evident early in design iterations that the rendering algorithms could be kept simple by only concerning themselves with the text visible on the display. That may seem obvious, but it is not necessarily intuitive when thinking through possible solutions. Notably, the rendering algorithm is based on two critical reference points in the buffer: one representing the top line of the display, and the other representing the line of the cursor. All movement and mutating operations are relative to these two points of reference. An earlier version used only one reference point, the current line, but it became clear that tracking the top line made a number of operations more efficient. The tradeoff with this algorithmic approach is that the majority of movement operations are _O(n)_, but in practice, these tend to be small distances, so the complexity that would come with implementing something more efficient than _O(n)_ would be hard to justify.

A _keyboard_ abstraction encapsulates the terminal, which is switched to _raw_ mode as part of initialization. The job of the keyboard is to interpret ANSI control sequences read from _stdin_ and turn those into _keys_. A key, or a sequence of keys, is bound to some editing operation, whether it be the simple insertion of a character or something more complex such as pasting text from the clipboard. In order to make the association between _key sequence_ and _editing operation_ more flexible, this binding process happens at runtime using a finite set of key names and editing operations. While `ped` does provide default bindings, these can be altered through configuration files.

An _editor_ is perhaps one of the more complicated data structures that combines a _buffer_ and a _window_. The purpose of the editor is to implement editing primitives that modify the underlying buffer and then determine how those changes are rendered in the window. The editing operations, which are bound to keys at runtime, are actually defined outside of the _editor_ in `op.rs`. The idea is that all current and future operations can be built using the editor primitives.

The entire editing experience is facilitated by a central _controller_, which in a simplified sense, reads keys and calls their corresponding editing operations. The controller also manages the workspace, which contains a collection of windows, and provides a restricted _environment_ to functions that implement editing operations. It also coordinates interaction with the user in the form of _questions_, such as opening a file or asking to save a dirty buffer.

The concept of a _question_ is implemented using an _inquirer_ combined with a _completer_, both of which are abstractions that allow the controller to deal only with the general problem. This design allows the development of arbitrarily complex interactions, such as the _open file_ dialog that provides file completion assistance.

The _workspace_ supports multiple windows that split vertically with equal allocation of screen real estate. This was an early decision to keep the windowing system simple, at least for now. The workspace also manages resizing of windows when a change in the terminal size is detected.

The implementation of _syntax_ highlighting uses familiar constructs, such as regular expressions to define tokens, as well as external configuration files that are discovered and loaded at runtime. The algorithmic challenge that became evident quite early in the design process was how to apply color updates efficiently as changes were occurring in the buffer. The fundamental problem is that the insertion or removal of text requires some degree of rescanning because existing tokens may be invalidated and new tokens may be recognized. However, it is not immediately obvious where to start the rescanning process. A classic example that illustrates the problem is the multi-line comment. Suppose the comment is opened on line 1 with a `/*`, but never closed. This implies that the comment token is never recognized. Now, suppose the comment is closed on line 1000 with `*/`. The entire buffer would need to be rescanned to correctly tokenize the text. In the interest of simplicity, I chose to rescan the entire buffer when changes are made. The tokenization process produces a vector of _spans_ that map to recognized tokens in the buffer. This data structure is very efficient for navigation and scrolling even though it requires _O(n)_ time to move forward and backward. It also aligns well with the rendering process. Insertion and removal of text uses a clever trick, essentially expanding a span during insertion or collapsing spans upon removal. These operations are very efficient, executing in _O(1)_ time. More importantly, the rescanning process can be deferred while making the immediate rendering operation behave as one might expect even though coloring for a brief period of time may not be entirely accurate. The need to rescan is detected and executed in background processing, which occurs between keystrokes. It turns out that the CPU is sitting idle most of the time, which makes background processing the ideal place to perform this relatively costly tokenization. Despite the deferral of rescanning, this operation is being executed on the same thread as the controller, so the cost of tokenization must be sensitive to the perception of sluggish responsiveness to users.
